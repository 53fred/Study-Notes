# 1. 基本概念
- 重载运算符名字由关键字operator和其后要定义的运算符号共同组成。重载运算符也包含返回类型、参数列表以及函数体。
- 重载运算符参数数量：一元运算符有一个参数，二元运算符有两个。
- 如果一个运算符函数是成员函数，则它的第一个运算对象绑定到隐式的this指针上。因此，成员运算符函数的显式参数数量比运算符的运算对象总数少一个。
- 对于一个运算符函数，它或者是类的成员，或者有至少一个类类型的参数，**不能为内置类型重定义运算符**。  
- 可以直接调用一个重载的运算符函数：  

```C++
data1 + data2;
operator+(data1, data2);    //等价的函数调用

//调用成员运算符函数：
data1 += data2;
data1.operator+=(data2);
```
## 1.1. 选择作为成员或者非成员
- 赋值(=)、下标([])、调用(())和成员访问运算符(->)必须是成员；
- 复合赋值运算符一般是成员；
- 改变对象状态的运算符，如递增、递减和解引用，通常是成员；
- 具有对称性的运算符，通常是非成员。

# 2. 输入和输出运算符
## 2.1. 重载输出运算符
- 通常情况下，输出运算符的第一个形参是一个非常量ostream对象的引用。非常量：向流写入内容会改变其状态；引用：因为无法直接复制一个ostream对象。
- 第二个形参一般是一个常量的引用，该常量是要打印的类类型。常量：打印通常不改变对象内容；引用：避免复制实参。
- operator<<一般要返回它的ostream形参。  

```C++
ostream &operator<<(ostream &os, const Sales_item& item)
{
    os << item.isbn();
    return os;
}
```
- 输出运算符尽量减少格式化操作：输出运算符应该主要负责打印对象的内容，而非控制格式。
- 输入输出运算符**必须是非成员函数**，一般被声明为友元。

## 2.2. 重载输入运算符
- 通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用。
- 第二个形参是将要读入到的对象的引用。
- 通常返回给定流的引用。  

```C++
istream &operator>>(istream &is, Sales_item& item)
{
    is << item.isbn();
    if (is)
    {
        //success
    }
    else
    {
        //error
    }
    return is;
}
```
- **输入运算符必须处理输入可能错误的情况，输出运算符不需要**。

### 2.2.1. 输入时可能的错误
- 流含有错误类型的数据；
- 读取操作到达文件的末尾或者遇到输入流的其他错误。

# 3. 算术和关系运算符
- 通常情况下，把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符不需要改变运算对象的状态，所以形参都是常量的引用。
- 应当使用复合赋值来定义算数运算符：  

```C++
Sales_Data operator+(const Sales_Data &lhs, const Sales_Data &rhs)
{
    Sales_Data sum = lhs;
    sum += rhs;
    return sum;
}

Sales_Data& operator+=(const Sales_Data &lhs)
{
    no += lhs.no;
    return *this;
}  
```  

## 3.1. 相等运算符
- 如果一个类定义了operator==，则也应该定义operator!=。
- 相等运算符和不等运算符应该把工作委托给另外一个，意味着其中一个运算符应该负责实际比较对象的工作，另一个运算符只是调用那个真正工作的运算符。

## 3.2. 关系运算符
- 如果存在唯一一种逻辑可靠的<定义，则应该考虑为这个类定义<运算符。如果类同时还包含==，则当且仅当<的定义和==产生的结果一致时才定义<运算符。

# 4. 赋值运算符
