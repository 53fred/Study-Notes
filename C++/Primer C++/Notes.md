# Chap2 变量和基本类型
## 1. 带符号类型与无符号类型
切勿混用带符号类型与无符号类型。如果表达式中既有带符号类型，又有无符号类型，当带符号类型取值为负时会出现异常结果，因为带符号数会自动转换为无符号数。
```C++
unsighed u1 = 10, u2 = 20;
int i = 15;
cout << i - u1 << endl << u1 - i << endl;
cout << i - u2 << endl << u2 - i << endl;
```
**输出结果：**  
5  
4294967291  
4294967291  
5  
**解释：** 负数变为无符号数：unsigned int模：4294967296，-5 + 4294967296 = 4294967291
## 2. 整型和浮点型字面值
可以将整型字面值写为8进制、16进制。0开头的整数代表8进制，0x或0X开头代表16进制。  
浮点型字面值表示为小数或以科学计数法表示的指数。
> 3.1415 3.1415e2
## 3. 列表初始化
在C++11中，可以用花括号括起来的初始值为对象初始化或赋新值。  
如果使用列表初始化且存在丢失信息的风险，编译器会报错：
```C++
long double ld = 3.1415;
int a{ld}; //错误
int b(ld), c = ld; //正确
```
## 4. 引用
- 引用必须初始化  
- 引用只能绑定在对象上
```C++
int i = 1;
int &a; //错误
int &b = i; //正确
int &c = 10; //错误
```
- 指向指针的引用：
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，存在对指针的引用：
```C++
int i = 40;
int *p;
int *&r = p;
r = &i;   //等于将p指向i
*r = 0;   //等于i = 0
```
## 5. void指针
可用于存放任意对象的地址，但不能直接操作指针所指对象。

## 6. decltype
作用是选择并返回操作数的数据类型。  
decltype处理const与auto的区别：decltype返回变量的类型包括const与引用
```C++
const int ci = 0, &ci = cj;
decltype(ci) x = 0; //x的类型是const int
decltype(cj) y = x; //y的类型是const int &，y绑定到x
decltype(cj) z;     //错误，引用必须初始化

int i = 42, *p = &i;
decltype(*p) c;     //错误，c是int&，必须初始化
```
