# 1. lambda表达式
- C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。
- Lambda 的语法形式如下：

```C++
[函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}

Eg：stable_sort(words.begin(), words.end(), [](const string &a, const string &b){return a.size() < b.size();});
```

- 可以看到，Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-> 返回值类型、{函数体}。

## 1.1. 语法分析
### 1.1.1. [函数对象参数]
- 标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。  

- 函数对象参数有以下形式：
1. 空。没有任何函数对象参数。  
2. =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。  
3. &。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。  
4. this。函数体内可以使用 Lambda 所在类中的成员变量。  
5. a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。  
6. &a。将 a 按引用进行传递。  
7. a，&b。将 a 按值传递，b 按引用进行传递。  
8. =，&a，&b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。  
9. &，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。

### 1.1.2. (操作符重载函数参数)
- 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&a, &b)) 两种方式进行传递。

### 1.1.3. mutable 或 exception 声明
- 这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。

### 1.1.4. -> 返回值类型
- 标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。

### 1.1.5. {函数体}
- 标识函数的实现，这部分不能省略，但函数体可以为空。

## 1.2. 示例

```C++
[] (int x, int y) { return x + y; } // 隐式返回类型
[] (int& x) { ++x;  }               // 没有 return 语句 -> Lambda 函数的返回类型是 'void'
[] () { ++global_x;  }              // 没有参数，仅访问某个全局变量
[] { ++global_x; }                  // 与上一个相同，省略了 (操作符重载函数参数)

//指定返回类型：
[] (int x, int y) -> int { int z = x + y; return z; }
```

- Lambda 函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在 Lambda 表达式声明中的方括
号 [] 内。这个机制允许这些变量被按值或按引用捕获。

```C++
[]      //未定义变量，不可以在lambda内使用外部变量
[x,&y]  //x按值捕获，y按引用捕获
[&]     //用到的任何外部变量都隐式按引用捕获
[=]     //用到的任何外部变量都隐式按值捕获
[&,x]     //x显式按值捕获，其余变量按引用捕获
[=,&z]     //z显式按引用捕获，其余变量按值捕获
```
