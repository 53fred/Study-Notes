# 1. 拷贝、赋值与销毁
- 五种特殊的成员函数：  
1. 拷贝构造函数  
2. 拷贝赋值运算符  
3. 移动构造函数  
4. 移动赋值运算符  
5. 析构函数  

拷贝和移动构造函数定义了当用同类型的一个对象初始化本对象时做什么。  
拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。  
析构函数定义了此类型对象销毁时的操作。

## 1.1. 拷贝构造函数
- 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
- 每个成员的类型决定了它的拷贝方式，类类型调用其拷贝构造函数；对于内置类型，直接拷贝；对于数组的拷贝是逐个元素的拷贝。
```C++
class Foo{
public:
    Foo();  //默认构造函数
    Foo(const Foo&);  //拷贝构造函数
}
```  
- 拷贝构造函数通常不应该是explicit的。

### 1.1.1. 直接初始化与拷贝初始化区别
```C++
string dots(10, '.');   //直接初始化
string s(dots);         //直接初始化
string s2 = dots;       //拷贝初始化
string s3 = "abc";      //拷贝初始化
string s4 = string(10, '.');   //拷贝初始化
string *s5 = new string(s2);   //拷贝初始化
```

### 1.1.2. 拷贝初始化发生的情况
- 用=**定义**变量；
- 将一个对象作为实参传递给一个非引用类型的形参；  
- 从一个返回类型为非引用类型的函数返回一个对象；  
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。  
某些类类型还会对他们分配的对象使用拷贝初始化。  
Eg：调用insert和push进行拷贝初始化，调用emplace进行直接初始化。  

### 1.1.3. 错误分析
```C++
Sales_data::Sales_data(Sales_data rhs);
```
- 此为一个类的拷贝构造函数，作为函数其非引用类型的参数需要进行拷贝初始化，要调用拷贝构造函数以拷贝实参，无限循环。

## 1.2. 拷贝赋值运算符
```C++
sales s1, s2;
s1 = s2;    //拷贝赋值运算符
```
### 1.2.1. 重载赋值运算符
- 拷贝赋值运算符，其实就是一个名为operator=的函数(operator后加表示要定义的运算符符号)。  
- 重载拷贝赋值运算符，有返回类型和参数，返回类型通常是左侧运算符的引用。对于一个二元运算符，比如赋值运算符，其右侧运算对象作为显式参数传递。
- 若在类内未显式定义，则编译器会自动生成**合成拷贝赋值运算符**，将运算符右侧的所有非static成员赋给左侧对象对应成员。
```C++
class Foo{
public:
    Foo& operator=(const Foo&); //赋值运算符    
};
```

## 1.3. 析构函数
- 析构函数释放对象使用的资源，并销毁对象的非static数据成员。
```C++
class Foo{
public:
    ~Foo();
};
```
### 1.3.1. 调用析构函数的情况
- 变量在离开其作用域时被销毁；
- 当一个变量被销毁时，其成员被销毁；
- 容器被销毁时，其元素被销毁；
- 动态分配的对象，delete时被销毁；
- 临时对象，创建它的完整表达式结束时被销毁。    


- 合成析构函数：**函数体为空**，成员会被自动销毁。
- **析构函数体自身并不直接销毁成员，成员在析构函数体之后隐含的析构阶段被销毁**。
- 当指向一个对象的引用或者指针离开作用域时，析构函数并不会执行。

## 1.4. 三/五法则
- 需要析构函数的类也需要一个拷贝构造函数和一个拷贝赋值运算符。
- 需要拷贝操作的类也需要赋值操作，反之亦然。

## 1.5. 使用=default
- 可以对拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。
```C++
class Sales_data{
public:   
     Sales_data() = default;
     Sales_data(const Sales_data&) = default;
     ~Sales_data() = default;
};
```
- **在类内使用=default时，合成的函数会隐式地声明为内联的，就像其他类内声明的成员函数一样**。
- 如果不希望合成的成员函数是内联的，应该只对成员的类外定义使用=default。

## 1.6. 阻止拷贝
- 我们通过将拷贝构造函数和拷贝赋值运算符定义为删除函数来阻止拷贝。
- 删除函数：我们声明了它们，但不能用任何方式使用它们。
```C++
class Sales_data{
public:   
     Sales_data() = default;
     Sales_data(const Sales_data&) = delete;                //阻止拷贝
     Sales_data& operator=(const Sales_data&) = delete;     //阻止赋值
     ~Sales_data() = default;
};
```
- 与default不同，=delete必须出现在第一次声明处。
- 析构函数不能是删除的成员.
- 在=delete发布之前，是通过将拷贝构造函数和拷贝赋值运算符定义为private，声明但不定义，来阻止拷贝的。
