# 1. 概述
## 1.1. 继承
- 对于某些函数，基类希望它的派生类各自定义自己的版本，此时将函数声明为虚函数。
- 类派生列表：冒号后面紧跟以逗号分隔的基类列表，每个基类前面可以有访问说明符。  

```C++
class Bulk:public class Quote
```  

## 1.2. 动态绑定

```C++
double print_total(const Quote&item);
```

- 因为print_total的形参是基类Quote的一个引用，我们既能使用基类调用该函数，也能使用派生类Bulk调用它。
- 因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，因此动态绑定又被称为运行时绑定。

# 2. 定义基类和派生类
## 2.1. 定义基类
- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际的操作也是如此。
- 如果一个基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。
- 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。protected运算符使派生类可以访问基类的数据成员。

## 2.2. 定义派生类
- 如果派生类没有覆盖基类的某个虚函数，派生类会直接继承其在基类中的版本。
- 派生类可以在它覆盖的函数前加virtual关键字，但不是必须这样做。    

### 2.2.1. 继承与静态成员
- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。
- **类的声明中不能包含它的派生列表**。

## 2.3. 类型转换与继承
- 可以将基类的指针或引用绑定到派生类对象。

- 当我们使用一个变量或者表达式时，我们需要将其静态类型和动态类型相互区分开，表达式的静态类型是在编译时已知的，是变量声明时的类型或者表达式生成的类型，其动态类型是变量或者表达式表示内存的对象的类型，知道运行时才可知。
- 如果表达式既不是指针也不是引用，则其动态类型和静态类型会一直绑定在一起。

# 3. 虚函数
- 所有虚函数都必须有定义.
- 动态绑定只有在通过指针或引用调用虚函数时才会发生.
- 引用和指针的静态类型与动态类型不同的这一事实是C++语言支持多态性的根本所在(必须是虚函数)

## 3.1. final和override说明符
- 在C++11中可以使用override关键字说明派生类中的虚函数.

```C++
struct a
{
    virtual void f1();
};
struct b:a
{
    void f1() override;
};
```

- final:将函数指定为final后,任何尝试覆盖该函数的操作都会引发错误.

```C++
struct c:a
{
    void f1() final;
};
struct d:b
{
    void f1();  //error
};
```

- 可以使用作用域运算符强制使用虚函数的某个版本.

```C++
double undiscounted = baseP->Quote::net_price(42);
```     

# 4. 抽象基类
## 4.1. 纯虚函数
- 纯虚函数无需定义,通过在函数体位置书写=0可以将一个虚函数声明为纯虚函数.
- 也可以为一个纯虚函数提供定义,但必须定义在类的外面.

- 含有纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。

# 5. 访问控制与继承    
## 5.1. 受保护的成员
- 对于类的用户不可访问，对于派生类的成员和友元可以访问。

## 5.2. 友元与继承
- 友元关系不能继承。
- 每个类负责控制自己的成员的访问权限。

```C++
Eg:
class Base{
    friend class Pal;
    int i;
};
class S:Base{
    int s;
};
class Pal{
    int f(Base b){return b.i;}  //true
    int f2(S s){return s.s;}    //false
    int f3(S s){return s.i;}    //true
};
```

## 5.3. 改变个别成员的可访问性
- 有时需要改变派生类继承的某个成员的访问级别，通过使用using声明达到这一目的。

```C
class Base{
public:
    int size() const{return n;}
protected:
    int n;
}
class Derived:private Base{
public:
    using Base::size;
protected:
    using Base::n;
}
```

- 因为继承了private的base，继承而来的成员是Derived的私有成员。使用using语句改变了这些成员的可访问性。
- **派生类只能为它可以访问的名字使用using。**

## 5.4. 类型转换
1： 假定B继承自A，无论B以什么方式继承A，B的成员函数和友元都能使用派生类到基类的转换   
2： B继承A的方式是公有或者保护，则B的派生类的成员或友元可以使用B到A的转换，若未私有则不行   
3： B继承A的方式是公有的，用户的代码才能使用B到A的（派生类到基类）的转换，保护或者私有方式则不行  

## 5.5. 继承方式
- 不同的继承方式：   
1. **public继承：** 基类public成员，protected成员，private成员的访问属性在派生类中分别变成：
public(类内：可访问（直接访问）；类外：可访问（直接访问）)，  
protected(类内：可访问（直接访问）；类外：可访问（间接访问）)，  
private(类内：可访问（间接访问）；类外：可访问（间接的间接访问）)  

2. **protected继承：**基类public成员，protected成员，private成员的访问属性在派生类中分别变成：   
protected(类内：可访问（直接访问）；类外：可访问（间接访问）)，  
protected(类内：可访问（直接访问）；类外：可访问（间接访问）)，  
private(类内：可访问（间接访问）；类外：可访问（间接的间接访问）)  

3. **private继承**：基类public成员，protected成员，private成员的访问属性在派生类中分别变成：   
private(类内：可访问（直接访问）；类外：可访问（间接访问）)，  
private(类内：可访问（直接访问）；类外：可访问（间接访问）)，  
private(类内：可访问（间接访问）；类外：可访问（间接的间接访问）)

# 6. 继承中的类作用域
## 6.1. 通过作用于运算符来使用隐藏的成员
```C++
struct Derived:Base{
    int get_num(){return Base::num;}
};
```

- 名字查找优先于类型检查，**派生类中的函数并不会重载基类中的函数**。    
如果派生类的某个成员与基类的某个成员名称相同，即使参数列表不同，派生类也会在作用域内隐藏掉基类成员。

- 虚函数：动态绑定，代码在运行时确定使用虚函数的哪个版本。
- 非虚函数：静态绑定，调用的函数版本由指针的静态类型决定。

```C++
//virtual function
Base *bp1 = &bobj, *bp2 = &d1obj;
bp1->fun();     //base::fun
bp2->fun();     //D1::fun
//non-virtual function
Base *p1 = &d1obj;  
D1 *p2 = &d1obj;
p1->fun();      //base::fun, though object is D1
p2->fun();      //D1::fun
```

# 7. 构造函数与拷贝控制
