# 1. 概述
## 1.1. 继承
- 对于某些函数，基类希望它的派生类各自定义自己的版本，此时将函数声明为虚函数。
- 类派生列表：冒号后面紧跟以逗号分隔的基类列表，每个基类前面可以有访问说明符。  

```C++
class Bulk:public class Quote
```  

## 1.2. 动态绑定

```C++
double print_total(const Quote&item);
```

- 因为print_total的形参是基类Quote的一个引用，我们既能使用基类调用该函数，也能使用派生类Bulk调用它。
- 因为在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，因此动态绑定又被称为运行时绑定。

# 2. 定义基类和派生类
## 2.1. 定义基类
- 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际的操作也是如此。
- 如果一个基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。
- 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。protected运算符使派生类可以访问基类的数据成员。

## 2.2. 定义派生类
- 如果派生类没有覆盖基类的某个虚函数，派生类会直接继承其在基类中的版本。
- 派生类可以在它覆盖的函数前加virtual关键字，但不是必须这样做。    

### 2.2.1. 继承与静态成员
- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。
- **类的声明中不能包含它的派生列表**。

# 3. 类型转换与继承
- 可以将基类的指针或引用绑定到派生类对象。

- 当我们使用一个变量或者表达式时，我们需要将其静态类型和动态类型相互区分开，表达式的静态类型是在编译时已知的，是变量声明时的类型或者表达式生成的类型，其动态类型是变量或者表达式表示内存的对象的类型，知道运行时才可知。
- 如果表达式既不是指针也不是引用，则其动态类型和静态类型会一直绑定在一起。
