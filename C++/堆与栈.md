# 栈和堆的区别
- **申请后系统响应：** 分配栈空间：如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；  
申请堆空间：堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。
- 栈在内存中是**连续的一块空间（向低地址扩展）**最大容量是系统预定好的，堆在内存中的**空间（向高地址扩展）是不连续的**。
- 申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。

# 限制对象只能在堆/栈上建立
C++ 中的类的对象的建立分为两种：**静态建立、动态建立。**  
**静态建立：** 由编译器为对象在栈空间上分配内存，直接调用类的构造函数创建对象。例如：A a;  
**动态建立：** 使用 new 关键字在堆空间上创建对象，底层首先调用 operator new() 函数，在堆空间上寻找合适的内存并分配；然后，调用类的构造函数创建对象。例如：A* p = new A();  
## 1.限制对象只能建立在堆上：
**最直观的思想：**   
避免进行静态建立。避免直接调用类的构造函数，因为对象静态建立时，会调用类的构造函数创建对象。但是直接**将类的构造函数设为私有并不可行**，因为当构造函数设置为私有后，不能在类的外部调用构造函数来构造对象，只能用 new 来建立对象。但是**由于 new 创建对象时，底层也会调用类的构造函数**，将构造函数设置为私有后，那就无法在类的外部使用 new 创建对象了。因此，这种方法不可行。  

### 解决方法 1： 将析构函数设置为私有
**原因：** 静态对象建立在栈上，是由编译器分配和释放内存空间，**编译器为对象分配内存空间时，会对类的非静态函数进行检查，即编译器会检查析构函数的访问性**。当析构函数设为私有时，编译器创建的对象就无法通过访问析构函数来释放对象的内存空间，因此，编译器不会在栈上为对象分配内存。
```C++
Eg：class A
{
public:
    A() {}
    void destroy()
    {
        delete this;
    }

private:
    ~A()
    {
    }
};
int main
{
  A *p = new A();
  p->destroy();
}
```
**该方法存在的问题：**  
- 用 new 创建的对象，通常会使用 delete 释放该对象的内存空间，但此时类的外部无法调用析构函数，因此类内**必须定义一个 destory() 函数**，用来释放 new 创建的对象。
- **无法解决继承问题**，因为如果这个类作为基类，析构函数要设置成 virtual，然后在派生类中重写该函数，来实现多态。但此时，析构函数是私有的，派生类中无法访问。
- **注：** 我尝试**将析构函数设为protected**，编译器同样不会在栈上为对象分配内存，同时又解决了继承的问题。

### 解决方法2：
**构造函数设置为 protected，并提供一个 public 的静态函数来完成构造，而不是在类的外部使用 new 构造；将析构函数设置为 protected**。  
**原因：** 类似于单例模式，也保证了在派生类中能够访问析构函数。通过调用 create() 函数在堆上创建对象。
```C++
Eg：class A
{
protected:
    A() {}
    ~A() {}

public:
    static A *create()
    {
        return new A();
    }
    void destory()
    {
        delete this;
    }
};
int main
{
  A *p = new A();
  p->destroy();
}
```
