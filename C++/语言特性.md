# C++ 11 新特性
## 1. auto 类型推导
auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
```
**注意：** 编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

## 2. decltype 类型推导
decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
decltype(val1 + val2) var1 = 0; 
```

## 3. lambda 表达式
使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。
而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。  
对于**只使用一次的函数对象类**，能否直接在使用它的地方定义呢？Lambda 表达式能够解决这个问题。使用 Lambda 表达式可以减少程序中函数对象类的数量，使得程序更加优雅。
```C++
[外部变量访问方式说明符] (参数表) -> 返回值类型
{
   语句块
}
```
其中，“外部变量访问方式说明符”可以是=或&，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&表示允许。当然，在{}中也可以不使用定义在外面的变量。“-> 返回值类型”可以省略。
```C++
Eg：[=] (int x, int y) -> bool {return x%10 < y%10; }

int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```
这段程的输出结果是：  
11 2 33 4

实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：
- [=, &x, &y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；
- [&, x, y]表示除 x、y 以外的外部变量，值都可以被修改。

## 4. 范围for语句
```C++
for (declaration : expression){
    statement
}
```
expression部分是一个对象，必须是一个序列，比方说用花括号括起来的初始值列表、数组或者vector或string等类型的对象。这些类型的共同特点是拥有能返回迭代器的begin和end成员。  
declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。确保类型相容最简单的办法是使用auto类型说明符。  
基于范围的 for 循环使用了一个称为范围变量的内置变量。每次基于范围的 for 循环迭代时，它都会复制下一个数组元素到范围变量。例如，第一次循环迭代，范围变量将包含元素 0 的值；第二次循环迭代，范围变量将包含元素 1 的值，以此类推。

**使用基于范围的 for 循环来修改数组：**  
当基于范围的 for 循环执行时，其范围变量将仅包含一个数组元素的副本。因此，不能使用基于范围的 for 循环来修改数组的内容，除非将范围变量声明为一个引用。引用变量是其他值的一个别名，任何对于引用变量的修改都将实际作用于别名所代表的值。  

要将范围变量声明为引用变量，可以在循环头的范围变量名称前面添加一个 & 符号。
```C++
for (int &val : numbers){
    statement
}
```
## 5. 右值引用
右值引用：绑定到右值的引用，用 && 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。

**左值引用：**
```C++
int a = 10; 
int& refA = a; // refA是a的别名， 修改refA就是修改a, a是左值，左移是左值引用

int& b = 1; //编译错误! 1是右值，不能够使用左值引用
```

**右值引用：**
```C++
int&& a = 1; //实质上就是将不具名(匿名)变量取了个别名
int b = 1;
int && c = b; //编译错误！ 不能将一个左值复制给一个右值引用
class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
```
左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。  
常量左值引用却可以算是一个“万能”的引用类型，它**可以绑定非常量左值、常量左值、右值**，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。
```C++
const int & a = 1; //常量左值引用绑定 右值， 不会报错
class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
const A & a = getTemp();   //不会报错 而 A& a 会报错
```
- 左值引用， 使用 T&, 只能绑定左值
- 右值引用， 使用 T&&， 只能绑定右值
- 常量左值， 使用 const T&, 既可以绑定左值又可以绑定右值
- 已命名的右值引用，编译器会认为是个左值

## 6. move(STL move)函数
move() 算法会将它的前两个输入迭代器参数指定的序列移到第三个参数定义的目的序列的开始位置，第三个参数必须是输出迭代器。这个算法返回的迭代器指向最后一个被移动到目的序列的元素的下一个位置。
```C++
std::vector<int> srce {1, 2, 3, 4};
std::deque<int> dest {5, 6, 7, 8};
std::move(std::begin(srce), std::end(srce), std::back_inserter(dest));
```
这是一个移动操作，因此无法保证在进行这个操作之后，输入序列仍然保持不变；源元素仍然会存在，但它们的值可能不再相同了，因此在移动之后，就不应该再使用它们。如果源序列可以被替换或破坏，就可以选择使用 move() 算法。如果不想扰乱源序列，可以使用 copy() 算法。
## 7. 智能指针
## 8. delete 函数和 default 函数
- delete 函数：= delete 表示该函数不能被调用。  
- default 函数：= default 表示编译器生成默认的函数，例如：生成默认的构造函数。
```C++
class A
{
public:
	A() = default; // 表示使用默认的构造函数
	~A() = default;	// 表示使用默认的析构函数
	A(const A &) = delete; // 表示类的对象禁止拷贝构造
	A &operator=(const A &) = delete; // 表示类的对象禁止拷贝赋值
};
int main()
{
	A ex1;
	A ex2 = ex1; // error: use of deleted function 'A::A(const A&)'
	A ex3;
	ex3 = ex1; // error: use of deleted function 'A& A::operator=(const A&)'
	return 0;
}
```

# Java 和 C++ 的区别
- 指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机（JVM）内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制。
- 多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便。
- 数据类型和类：Java 是完全面向对象的语言，所有函数和变量部必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而 C++ 允许将函数和变量定义为全局的。
- 垃圾回收：Java 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存。  
Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。
- C++ 可以直接编译成可执行文件，运行效率比 Java 高。

# Python 和 C++ 的区别
- 语言自身：Python 为脚本语言，解释执行，不需要经过编译；C++ 是一种需要编译后才能运行的语言，在特定的机器上编译后运行。
- 运行效率：C++ 运行效率高，安全稳定。首先，Python 中涉及的内容比 C++ 多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python 是解释执行的，和物理机 CPU 之间多了解释器这层，而 C++ 是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。

