# C++ 11 新特性
## 1. auto 类型推导
auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
```
**注意：** 编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

## 2. decltype 类型推导
decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
decltype(val1 + val2) var1 = 0; 
```

## 3. lambda 表达式
使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。
而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。  
对于**只使用一次的函数对象类**，能否直接在使用它的地方定义呢？Lambda 表达式能够解决这个问题。使用 Lambda 表达式可以减少程序中函数对象类的数量，使得程序更加优雅。
```C++
[外部变量访问方式说明符] (参数表) -> 返回值类型
{
   语句块
}
```
其中，“外部变量访问方式说明符”可以是=或&，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&表示允许。当然，在{}中也可以不使用定义在外面的变量。“-> 返回值类型”可以省略。
```C++
Eg：[=] (int x, int y) -> bool {return x%10 < y%10; }

int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```
这段程的输出结果是：  
11 2 33 4

实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：
- [=, &x, &y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；
- [&, x, y]表示除 x、y 以外的外部变量，值都可以被修改。

## 4. 范围for语句
```C++
for (declaration : expression){
    statement
}
```
expression部分是一个对象，必须是一个序列，比方说用花括号括起来的初始值列表、数组或者vector或string等类型的对象。这些类型的共同特点是拥有能返回迭代器的begin和end成员。  
declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。确保类型相容最简单的办法是使用auto类型说明符。  
基于范围的 for 循环使用了一个称为范围变量的内置变量。每次基于范围的 for 循环迭代时，它都会复制下一个数组元素到范围变量。例如，第一次循环迭代，范围变量将包含元素 0 的值；第二次循环迭代，范围变量将包含元素 1 的值，以此类推。

**使用基于范围的 for 循环来修改数组：**  
当基于范围的 for 循环执行时，其范围变量将仅包含一个数组元素的副本。因此，不能使用基于范围的 for 循环来修改数组的内容，除非将范围变量声明为一个引用。引用变量是其他值的一个别名，任何对于引用变量的修改都将实际作用于别名所代表的值。  

要将范围变量声明为引用变量，可以在循环头的范围变量名称前面添加一个 & 符号。
```C++
for (int &val : numbers){
    statement
}
```
## 5. 右值引用
右值引用：绑定到右值的引用，用 && 来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。

**左值引用：**
```C++
int a = 10; 
int& refA = a; // refA是a的别名， 修改refA就是修改a, a是左值，左移是左值引用

int& b = 1; //编译错误! 1是右值，不能够使用左值引用
```

**右值引用：**
```C++
int&& a = 1; //实质上就是将不具名(匿名)变量取了个别名
int b = 1;
int && c = b; //编译错误！ 不能将一个左值复制给一个右值引用
class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
A && a = getTemp();   //getTemp()的返回值是右值（临时变量）
```
左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。  
常量左值引用却可以算是一个“万能”的引用类型，它**可以绑定非常量左值、常量左值、右值**，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。
```C++
const int & a = 1; //常量左值引用绑定 右值， 不会报错
class A {
  public:
    int a;
};
A getTemp()
{
    return A();
}
const A & a = getTemp();   //不会报错 而 A& a 会报错
```
- 左值引用， 使用 T&, 只能绑定左值
- 右值引用， 使用 T&&， 只能绑定右值
- 常量左值， 使用 const T&, 既可以绑定左值又可以绑定右值
- 已命名的右值引用，编译器会认为是个左值

## 6. move(STL move)函数
