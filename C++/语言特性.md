# C++ 11 新特性
## 1. auto 类型推导
auto 关键字：自动类型推导，编译器会在 编译期间 通过初始值推导出变量的类型，通过 auto 定义的变量必须有初始值。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
```
**注意：** 编译器推导出来的类型和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。

## 2. decltype 类型推导
decltype 关键字：decltype 是“declare type”的缩写，译为“声明类型”。和 auto 的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用 auto。decltype 作用是选择并返回操作数的数据类型。
```C++
auto var = val1 + val2; // 根据 val1 和 val2 相加的结果推断出 var 的类型
decltype(val1 + val2) var1 = 0; 
```

## 3. lambda 表达式
使用 STL 时，往往会大量用到函数对象，为此要编写很多函数对象类。有的函数对象类只用来定义了一个对象，而且这个对象也只使用了一次，编写这样的函数对象类就有点浪费。
而且，定义函数对象类的地方和使用函数对象的地方可能相隔较远，看到函数对象，想要查看其 operator() 成员函数到底是做什么的也会比较麻烦。  
对于**只使用一次的函数对象类**，能否直接在使用它的地方定义呢？Lambda 表达式能够解决这个问题。使用 Lambda 表达式可以减少程序中函数对象类的数量，使得程序更加优雅。
```C++
[外部变量访问方式说明符] (参数表) -> 返回值类型
{
   语句块
}
```
其中，“外部变量访问方式说明符”可以是=或&，表示{}中用到的、定义在{}外面的变量在{}中是否允许被改变。=表示不允许，&表示允许。当然，在{}中也可以不使用定义在外面的变量。“-> 返回值类型”可以省略。
```C++
Eg：[=] (int x, int y) -> bool {return x%10 < y%10; }

int a[4] = {11, 2, 33, 4};
sort(a, a+4, [=](int x, int y) -> bool { return x%10 < y%10; } );
for_each(a, a+4, [=](int x) { cout << x << " ";} );
```
这段程的输出结果是：  
11 2 33 4

实际上，“外部变量访问方式说明符”还可以有更加复杂和灵活的用法。例如：
- [=, &x, &y]表示外部变量 x、y 的值可以被修改，其余外部变量不能被修改；
- [&, x, y]表示除 x、y 以外的外部变量，值都可以被修改。

## 4. 范围for语句
```C++
for (declaration : expression){
    statement
}
```
expression部分是一个对象，必须是一个序列，比方说用花括号括起来的初始值列表、数组或者vector或string等类型的对象。这些类型的共同特点是拥有能返回迭代器的begin和end成员。  
declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。确保类型相容最简单的办法是使用auto类型说明符。  
基于范围的 for 循环使用了一个称为范围变量的内置变量。每次基于范围的 for 循环迭代时，它都会复制下一个数组元素到范围变量。例如，第一次循环迭代，范围变量将包含元素 0 的值；第二次循环迭代，范围变量将包含元素 1 的值，以此类推。

**使用基于范围的 for 循环来修改数组：**  
当基于范围的 for 循环执行时，其范围变量将仅包含一个数组元素的副本。因此，不能使用基于范围的 for 循环来修改数组的内容，除非将范围变量声明为一个引用。引用变量是其他值的一个别名，任何对于引用变量的修改都将实际作用于别名所代表的值。  

要将范围变量声明为引用变量，可以在循环头的范围变量名称前面添加一个 & 符号。
```C++
for (int &val : numbers){
    statement
}
```
