# 1. cout执行顺序
在cout输出多个函数返回值时。发现输出顺序与命令从左到右的顺序不一致。  

**根据 C++17 之前的标准**，operator<< 左右手侧求值的是非确定的。
> 既不先序于又不后序于另一函数调用的函数调用是非确定顺序的。  
> 若标量对象上的副效应相对使用同一标量对象的值的值计算无顺序，则行为未定义。  

**在C++17中:**
> 移位运算符表达式 E1<<E2 和 E1>>E2 中， E1 的每个值计算和副效应先序于 E2 的每个值计算和副效应。 (C++17 起)

# 2. #ifndef的作用
> 在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。  
> 但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。  
> 使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，**一个c文件包含同一个h文件多次**，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果**加了#ifndef，则不会出现这种错误**。  

**#ifndef只防止某.c重复include同一头文件。**  
不同.c去include同一头文件是可以的；如果这个头文件里定义了全局变量，每个include该头文件的.c都会生成各自的同名全局变量，导致重复定义。
```C++
Eg：其中 tst.h:
#ifndef TST_H
#define TST_H
int g_a;
#endif

tst1.cpp:
#include "tst.h"
void test()
{
    g_a++;
    cout << g_a << endl;
}

tst2.cpp:
#include "tst.h"
extern void test();
int main()
{
    cout << g_a << endl;
}
```
**编译结果：**
> multiple definition of `g_a'  

**而以下情况可以使用#ifndef避免：**
```C++
Eg：tst.h:
#ifndef TST_H
#define TST_H
int g_a;
#endif

tst3.cpp:
#include "tst.h"
#include "tst.h"
extern void test();
int main()
{
    //test();
    cout << g_a << endl;
}
```
**编译结果：**
> redefinition of ‘int g_a’    

# 3. 注释不可嵌套
```C++
cout << /* "*/" /* "/*" */;
```
输出结果为 （空格）/* （空格）

# 4. 可以连续赋值
```C++
a=b=c=88; //赋值从右到左进行，c=88，b=c，a=b
```

# 5. 判断两个string是否相等
不同于java的string.equals，直接用==判断即可。

# 6. 删除字符串中标点
- 使用remove_if，头文件<algorithm>  
- remove_if的参数是迭代器，前两个参数表示迭代的起始位置和停止位置，最后一个参数传入一个回调函数，如果回调函数返回为真，则将当前指向的参数移到尾部。返回值为被移动区域的首个元素。

```C++
line.erase(remove_if(line.begin(), line.end(), ispunct), line.end());
```

# 7. 地址加法与减法

当一个加法运算，加号两边的操作数一个是指针，另一个是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再和指针的值相加。  

当一个减法运算，减号左边的操作数是一个指针，右边的操作数是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再被指针的值减去。  

当一个减法运算，减号两边的操作数都是地址时，则这两个地址的数据类型必须一致（如都是int *类型），否则无法通过编译。减法运算的结果为地址值的差，再除以该地址的数据类型的大小（如sizeof(int)）。

# 8. 派生类构造函数调用顺序

- 派生类的构造函数: 派生类名(总参数表)：基类构造函数(参数名),子对象名(参数表) {派生类数据成员的初始化}

```C++
class A
 {
 public:
     A() {cout<<"A consturct."<<endl;}
 };
 class B:public A
 {
 public:
     B():A() {cout<<"B construct."<<endl;}
 };

 int main()
 {
     B b;
 }

 程序输出：A construct.
          B construct.
```

```C++
class A
 {
 public:
     A() {"cout<<"A construct1."<<endl;}
     A(int i)
     {
         x1 = i;
         cout<<"A construct2."<<endl;
     }
 private:
     int x1;
 };
 class B:public A
 {
 public:
     B() {cout<<"B construct1."<<endl;}
     B(int i):A(i+10)
     {
         x2 = i;
         cout<<"B construt2."<<endl;
     }
     void displayb() {cout<<"x2 = "<<x2<<endl;}
 private:
     int x2;
 };

 int main()
 {
     B b(2);
     b.displayb();
 }

 程序输出：
 A construct2.
 B construct2.
 x2 = 2
```
- 派生类对象构造函数在调用之前必须先调用基类构造，派生类构造函数中要表示对基类构造的调用，若是单一继承，派生类构造函数中可以省去基类构造，但是默认会调用无参构造（建议不要省去）。

# 9. 调用类的成员函数

```C++
错误代码：
class a{
public:
    int print_num(){return num;}
private:
    int num;
};
class b{
public:
    b(const a& a0){num = a0.print_num();}
private:
    int num;
}

报错：passing ‘const a’ as ‘this’ argument of ‘int a::print_num()’ discards qualifiers
```

- 错误原因：一个const对象不能调用非const成员函数，即使成员函数并没有改变对象成员的值，编译器也会以为其改变了对象。所以要想调用那个函数，就把那个函数设成const函数，也就是在函数后加const。

```C++
int print_num() const {return num;}
```

- 另外，const成员函数是可以与非const成员函数并存的，即可以形成重载。
- 我们假设调用语句为obj.foo()，如果obj为non-const对象，则调用foo()。如果obj为const对象，则调用foo()const。**另外要注意，假如没有提供foo()const，则const obj调用foo()将会报错。但假如是没有提供foo()，则non-const obj调用foo()const是完全没有问题的。也就是说，non-const对象可以调用const函数，但const对象不能调用non-const函数**。
