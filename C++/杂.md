# 1. cout执行顺序
在cout输出多个函数返回值时。发现输出顺序与命令从左到右的顺序不一致。  

**根据 C++17 之前的标准**，operator<< 左右手侧求值的是非确定的。
> 既不先序于又不后序于另一函数调用的函数调用是非确定顺序的。  
> 若标量对象上的副效应相对使用同一标量对象的值的值计算无顺序，则行为未定义。  

**在C++17中:**
> 移位运算符表达式 E1<<E2 和 E1>>E2 中， E1 的每个值计算和副效应先序于 E2 的每个值计算和副效应。 (C++17 起)

# 2. #ifndef的作用
> 在c语言中，对同一个变量或者函数进行多次声明是不会报错的。所以如果h文件里只是进行了声明工作，即使不使用# ifndef宏定义，多个c文件包含同一个h文件也不会报错。  
> 但是在c++语言中，#ifdef的作用域只是在单个文件中。所以如果h文件里定义了全局变量，即使采用#ifdef宏定义，多个c文件包含同一个h文件还是会出现全局变量重定义的错误。  
> 使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，**一个c文件包含同一个h文件多次**，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果**加了#ifndef，则不会出现这种错误**。  

**#ifndef只防止某.c重复include同一头文件。**  
不同.c去include同一头文件是可以的；如果这个头文件里定义了全局变量，每个include该头文件的.c都会生成各自的同名全局变量，导致重复定义。
```C++
Eg：其中 tst.h:
#ifndef TST_H
#define TST_H
int g_a;
#endif

tst1.cpp:
#include "tst.h"
void test()
{
    g_a++;
    cout << g_a << endl;
}

tst2.cpp:
#include "tst.h"
extern void test();
int main()
{
    cout << g_a << endl;
}
```
**编译结果：**
> multiple definition of `g_a'  

**而以下情况可以使用#ifndef避免：**
```C++
Eg：tst.h:
#ifndef TST_H
#define TST_H
int g_a;
#endif

tst3.cpp:
#include "tst.h"
#include "tst.h"
extern void test();
int main()
{
    //test();
    cout << g_a << endl;
}
```
**编译结果：**
> redefinition of ‘int g_a’    

# 3. 注释不可嵌套
```C++
cout << /* "*/" /* "/*" */;
```
输出结果为 （空格）/* （空格）

# 4. 可以连续赋值
```C++
a=b=c=88; //赋值从右到左进行，c=88，b=c，a=b
```

# 5. 判断两个string是否相等
不同于java的string.equals，直接用==判断即可。

# 6. 删除字符串中标点
- 使用remove_if，头文件<algorithm>  
- remove_if的参数是迭代器，前两个参数表示迭代的起始位置和停止位置，最后一个参数传入一个回调函数，如果回调函数返回为真，则将当前指向的参数移到尾部。返回值为被移动区域的首个元素。
```C++
line.erase(remove_if(line.begin(), line.end(), ispunct), line.end());

# 7. 地址加法与减法
当一个加法运算，加号两边的操作数一个是指针，另一个是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再和指针的值相加。  

当一个减法运算，减号左边的操作数是一个指针，右边的操作数是一个整数时，这个整数值先乘以指针指向的数据类型的大小（如sizeof(int)），然后再被指针的值减去。  

当一个减法运算，减号两边的操作数都是地址时，则这两个地址的数据类型必须一致（如都是int *类型），否则无法通过编译。减法运算的结果为地址值的差，再除以该地址的数据类型的大小（如sizeof(int)）。

```
